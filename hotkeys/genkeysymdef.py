#!/usr/bin/python
from __future__ import annotations
import re
import sys
from collections import defaultdict
from contextlib import suppress
from dataclasses import dataclass
from pathlib import Path
from typing import NamedTuple


class ParseLineResult(NamedTuple):
    keymacro: str
    keyname: str
    keysym: int


re_keymarco = re.compile(r'(?:Sun|XF86)?XK_(?:KEY_)?(.+)$')


def parse_line(line: str) -> ParseLineResult | None:
    keymacro, keysym_str = line.split(maxsplit=3)[1:3]
    match = re_keymarco.match(keymacro)
    if not match:
        print(f'Keymarco {keymacro!r} from line {line!r} does not match '
              f'pattern {re_keymarco.pattern!r}', file=sys.stderr)
        return None
    keyname = match.group(1)
    try:
        keysym = int(keysym_str, 16)
    except ValueError:
        print(f'Invalid keysym {keysym_str!r}', file=sys.stderr)
        return None
    return ParseLineResult(keymacro, keyname, keysym)


@dataclass
class KeysymDef:
    keyname_to_keysym: dict[str, int]
    keysym_to_keynames: dict[int, tuple[str, ...]]


def make_keysymdef() -> KeysymDef:
    include_path = Path('/usr/include/X11')
    include_names = ['keysymdef.h', 'XF86keysym.h', 'Sunkeysym.h']
    results: list[ParseLineResult] = []
    for include_name in include_names:
        with open(include_path / include_name) as include_file:
            for line in include_file:
                if line.startswith('#define ') and (result := parse_line(line)):
                    results.append(result)
    keyname_to_keysym: dict[str, int] = {}
    keysym_to_keynames: dict[int, dict[str, None]] = defaultdict(dict)
    for result in results:
        keyname = result.keyname
        keysym = result.keysym
        if keyname_to_keysym.get(keyname) in {None, keysym}:
            keyname_to_keysym[keyname] = keysym
            keysym_to_keynames[keysym][keyname] = None
        else:
            print(f'Dropping {result.keymacro!r}', file=sys.stderr)
    return KeysymDef(
        keyname_to_keysym,
        {keysym: tuple(keynames)
         for keysym, keynames in keysym_to_keynames.items()},
    )


def render(keysymdef: KeysymDef) -> str:
    parts: list[str] = []

    def append(*new_parts: str) -> None:
        parts.extend(new_parts)

    append(
        '# AUTOGENERATED - DO NOT EDIT!\n',
        'from __future__ import annotations\n',
        '\n',
        'keyname_to_keysym: dict[str, int] = {\n',
    )

    for keyname, keysym in keysymdef.keyname_to_keysym.items():
        append('    ', repr(keyname), ': ', str(keysym), ',\n')

    append(
        '}\n',
        '\n',
        'keysym_to_keynames: dict[int, tuple[str, ...]] = {\n',
    )

    for keysym, keynames in keysymdef.keysym_to_keynames.items():
        line_start_parts = ['    ', str(keysym), ': (']
        keyname_parts = [repr(keyname) for keyname in keynames]
        line_end_part = '),\n'
        line_parts = [*line_start_parts, ', '.join(keyname_parts)]
        if len(keyname_parts) == 1:
            line_parts.append(',')
        line_parts.append(line_end_part)
        if sum(len(line_part) for line_part in line_parts) >= 80:
            line_parts = [*line_start_parts, '\n']
            for keyname_part in keyname_parts:
                line_parts.append('        ')
                line_parts.append(keyname_part)
                line_parts.append(',\n')
            line_parts.append('    ')
            line_parts.append(line_end_part)

        append(*line_parts)

    append('}\n')
    return ''.join(parts)


def main():
    path = Path(__file__).resolve().parent / 'hotkeys/keysymdef.py'
    code = render(make_keysymdef())
    with suppress(FileNotFoundError):
        path.chmod(0o644)
    with open(path, 'w') as file:
        file.write(code)
    path.chmod(0o400)


if __name__ == '__main__':
    main()
